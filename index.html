<!DOCTYPE html>
<html>
<head>
	<link href="https://fonts.googleapis.com/css?family=Asap|Lato:700&display=swap" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="styles.css">
	<title></title>
</head>
<body>
	<div class="container">
		<nav id="navbar" class="navbar">
			<header>
				<h1 class="first-header">CSS Documentation</h1>
			</header>
			<ul>
				<li><a href="#css" class="nav-link">CSS</a></li>
				<li><a href="#flexbox" class="nav-link">Flexbox</a></li>
				<li><a href="#CSS_grid_layout" class="nav-link">CSS Grid Layout</a></li>
				<li><a href="#Z-index" class="nav-link">Z-Index</a></li>
				<li><a href="#Media_Queries" class="nav-link">Media Queries</a></li>
				<li><a href="#color" class="nav-link">Color</a></li>
				<li><a href="#::after_(:after)" class="nav-link">::after (:after)</a></li>
				<li><a href="#transform" class="nav-link">Transform</a></li>
				<li><a href="#Box_Shadow" class="nav-link">Box Shadow</a></li>
				<li><a href="#Line_Height" class="nav-link">Line Height</a></li>
				<li><a href="#Max_Width" class="nav-link">Max Width</a></li>
				<li><a href="#calc()" class="nav-link">calc()</a></li>
				<li><a href="#position" class="nav-link">Position</a></li>
				<li><a href="#@Keyframes" class="nav-link">@Keyframes</a></li>
				<li><a href="#overflow" class="nav-link">Overflow</a></li>
				<li><a href="#Text_Transform" class="nav-link">Text Transform</a></li>
				<li><a href="#display" class="nav-link">Display</a></li>
			</ul>
		</nav>
		<main id="main-doc" class="main-doc">
			<section class="main-section" id="css">
				<header>
					<h1>CSS</h1>
				</header>
				<p><strong>CSS</strong> (Cascading Style Sheets) is a declarative language that controls how webpages look in the browser. The browser applies CSS style declarations to selected elements to display them properly. A style declaration contains the properties and their values, which determine how a webpage looks.</p>
				<p>CSS is one of the three core Web technologies, along with HTML and JavaScript. CSS usually styles HTML elements, but can be also used with other markup languages like SVG or XML.</p>
				<p>A CSS rule is a set of properties associated with a selector. Here is an example that makes every HTML paragraph yellow against a black background:</p>
				<h3>Syntax</h3>
				<code>
					/* first the selector (p) indicate that all paragraphs will be affected by the rule ({color: black}) */ <br>
					p { color: black;}
				</code>
			</section>
			<section class="main-section" id="flexbox">
				<header>
					<h1>Flexbox</h1>
				</header>
				<p>CSS Flexible Box Layout is a module of CSS that defines a CSS box model optimized for user interface design, and the layout of items in one dimension. In the flex layout model, the children of a flex container can be laid out in any direction, and can “flex” their sizes, either growing to fill unused space or shrinking to avoid overflowing the parent. Both horizontal and vertical alignment of the children can be easily manipulated.</p>
				<h3>Syntax</h3>
				<p>To define the flexbox layout you must use the display reference and its value set to flex</p>
				<code>
					.container {
						display: flex;
					}
				</code>
				<h3>Flexbox references</h3>
				<ul>
					<li>align-content</li>
					<li>align-items</li>
					<li>justify-content</li>
				</ul>
			</section>

			<section class="main-section" id="CSS_grid_layout">
				<header>
					<h1>CSS Grid Layout</h1>
				</header>
				<p>CSS Grid Layout excels at dividing a page into major regions or defining the relationship in terms of size, position, and layer, between parts of a control built from HTML primitives.</p>
				<p>Like tables, grid layout enables an author to align elements into columns and rows. However, many more layouts are either possible or easier with CSS grid than they were with tables. For example, a grid container's child elements could position themselves so they actually overlap and layer, similar to CSS positioned elements.</p>
				<h3>Syntax</h3>
				<p>To define the flexbox layout you must use the display reference and its value set to grid</p>
				<code>
					.container {
						display: grid;
					}
				</code>
				<h3>Grid references</h3>
				<ul>
					<li>grid-template-columns</li>
					<li>grid-template-rows</li>
					<li>grid-column</li>
					<li>grid-row</li>
				</ul>
			</section>
			<section class="main-section" id="Z-index">
				<header>
					<h1>Z-index</h1>
				</header>
				<p>The z-index CSS property sets the z-order of a positioned element and its descendants or flex items. Overlapping elements with a larger z-index cover those with a smaller one</p>
				<p>To define the z-index property you must use the z-index  reference and its value set to keyword or integer </p>
				
				<code>
					.element {z-index: auto | integer;}
				</code>
				<h3>Value</h3>
				<dl>
					<dt>keyword | auto</dt>
					<dd><p>The box does not establish a new local stacking context. The stack level of the generated box in the current stacking context is the same as its parent's box.</p></dd>
					<dt><code>&ltinteger&gt</code></dt>
					<dd><p>This <integer> is the stack level of the generated box in the current stacking context. The box also establishes a local stacking context in which its stack level is 0. This means that the z-indexes of descendants are not compared to the z-indexes of elements outside this element.</p></dd>
				</dl>
			</section>
			<section class="main-section" id="Media_Queries">
				<header>
					<h1>Media Queries</h1>
				</header>
				<p>Media queries are useful when you want to modify your site or app depending on a device's general type (such as print vs. screen) or specific characteristics and parameters (such as screen resolution or browser viewport width).</p>
				<p>Media queries are used for the following:</p>
				<ul>
					<li>To conditionally apply styles with the CSS @media and @import at-rules.</li>
					<li>To target specific media for the <link>, <source>, and other HTML elements.</li>
					<li>To test and monitor media states using the Window.matchMedia() and MediaQueryList.addListener() JavaScript methods.</li>
				</ul>
				<h3>Syntax</h3>
				<code>
					@media (max-width: 900) {
						.element {
							margin: 0;
						}
					}
				</code>
			</section>
			<section class="main-section" id="color">
				<header>
					<h1>Color</h1>
				</header>
				<p>The &ltcolor&gt CSS data type represents a color in the RGB color space. A &ltcolor&gt may also include an alpha-channel transparency value, indicating how the color should composite with its background.</p>
				<p>A &ltcolor&gt can be defined in any of the following ways</p>
				<ul>
					<li>Using a keyword (such as blue or transparent)</li>
					<li>Using the RGB cubic-coordinate system (via the #-hexadecimal or the rgb() and rgba() functional notations)</li>
					<li>Using the HSL cylindrical-coordinate system (via the hsl() and hsla() functional notations)</li>
				</ul>
				<h3>Syntax</h3>
				<code>
					/* using background-color */ <br>
						/* Hexadecimal */<br>
					.element {background-color: #ffffff;} <br>
						/* RGB */ <br>
					.element { background-color: rgb(255 255, 255);} <br>
						/* RGBA */ <br>
					.element { background-color: rgba(255, 255, 255, 0.5);} <br>
						/* HSL */ <br>
					.element { background-color: hsl(270,60%,70%);} <br>
						/* HSLA*/ <br>
					.element { background-color: hsla(270,60%,70%, .15);}
				</code>
			</section>
			::after (:after)
			<section class="main-section" id="::after_(:after)">
				<header>
					<h1>::after (:after)</h1>
				</header>
				<p>In CSS, ::after creates a pseudo-element that is the last child of the selected element. It is often used to add cosmetic content to an element with the content property. It is inline by default.</p>
				<h3>Syntax</h3>
				<code>
					.element::after {content: "→";}
				</code>
			</section>
			<section class="main-section" id="transform">
				<header>
					<h1>Transform</h1>
				</header>
				<p>The transform CSS property lets you rotate, scale, skew, or translate an element. It modifies the coordinate space of the CSS visual formatting model.</p>
				<code>
					.element {transform: matrix(1, 2, 3, 4, 5, 6);} <br>
					.element {transform: translate(120px, 50%);} <br>
					.element {transform: scale(2, 0.5);}<br>
					.element {transform: rotate(0.5turn);}<br>
					.element {transform: skew(30deg, 20deg);}<br>
				</code>
				<p>The transform property can have multiple function values</p>
				<code>
					.element {transform: scale(0.5) translate(-100%, -100%);}
				</code>
			</section>
			<section class="main-section" id="Box_Shadow">
				<header>
					<h1>Box Shadow</h1>
				</header>
				<p>The box-shadow CSS property adds shadow effects around an element's frame. You can set multiple effects separated by commas. A box shadow is described by X and Y offsets relative to the element, blur and spread radii, and color.</p>
				<h3>Syntax</h3>
				<code>
					/* offset-x | offset-y | color */
					<br>
					.element {box-shadow: 60px -16px teal;}
					<br>
					/* offset-x | offset-y | blur-radius | color */
					<br>
					.element {box-shadow: 10px 5px 5px black;}
					<br>
					/* offset-x | offset-y | blur-radius | spread-radius | color */
					<br>
					.element {box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);}
					<br>
					/* inset | offset-x | offset-y | color */
					<br>
					.element {box-shadow: inset 5em 1em gold;}
				</code>
			</section>
			<section class="main-section" id="Line_Height">
				<header>
					<h1>Line Height</h1>
				</header>
				<p>The line-height CSS property sets the height of a line box. It's commonly used to set the distance between lines of text. On block-level elements, it specifies the minimum height of line boxes within the element. On non-replaced inline elements, it specifies the height that is used to calculate line box height</p>
				<code>
					/* Keyword value */
					<br>
					.element {line-height: normal;}
					<br>
					/* Unitless values: use this number multiplied
					<br>
					by the element's font size */
					<br>
					.element {line-height: 3.5;}
					<br>
					/* length values */
					<br>
					.element {line-height: 3em;}
					<br>
					/* percentage values */
					<br>
					.element {line-height: 34%;}
				</code>
			</section>
			<section class="main-section" id="Max_Width">
				<header>
					<h1>Max Width</h1>
				</header>
				<p>The max-width CSS property sets the maximum width of an element. It prevents the used value of the width property from becoming larger than the value specified by max-width</p>
				<h3>Syntax</h3>
				<code>
					/* length value */
					<br>
					max-width: 3.5em;
					<br>
					/* percentage value */
					<br>
					max-width: 75%;
				</code>
			</section>
			<section class="main-section" id="calc()">
				<header>
					<h1>calc()</h1>
				</header>
				<p>The calc() CSS function lets you perform calculations when specifying CSS property values. It can be used anywhere a length, frequency, angle, time, percentage, number, or integer is allowed.</p>
				<h3>Syntax</h3>
				<code>
					.element {width: calc(100% - 80px);}
				</code>
				<p>The calc() function takes a single expression as its parameter, with the expression's result used as the value. The expression can be any simple expression combining the following operators, using standard operator precedence rules:</p>
				<ul>
					<li>+ Addition</li>
					<li>- Subtraction</li>
					<li>* Multiplication. At least one of the arguments must be a number.</li>
					<li>/ Division. The right-hand side must be a number.</li>
				</ul>
			</section>
			<section class="main-section" id="position">
				<header>
					<h1>Position</h1>
				</header>
				<p>The position CSS property sets how an element is positioned in a document. The top, right, bottom, and left properties determine the final location of positioned elements.</p>
				<h3>Types of positioning</h3>
				<ul>
					<li>A positioned element is an element whose computed position value is either relative, absolute, fixed, or sticky. (In other words, it's anything except static.)</li>
					<li>A relatively positioned element is an element whose computed position value is relative. The top and bottom properties specify the vertical offset from its normal position; the left and right properties specify the horizontal offset.</li>
					<li>An absolutely positioned element is an element whose computed position value is absolute or fixed. The top, right, bottom, and left properties specify offsets from the edges of the element's containing block. (The containing block is the ancestor relative to which the element is positioned.) If the element has margins, they are added to the offset.</li>
					<li>A stickily positioned element is an element whose computed position value is sticky. It's treated as relatively positioned until its containing block crosses a specified threshold (such as setting top to value other than auto) within its flow root (or the container it scrolls within), at which point it is treated as "stuck" until meeting the opposite edge of its containing block.</li>
				</ul>
				<h3>Syntax</h3>
				<code>
					.element {position: static | relative | absolute | sticky | fixed;}
				</code>
				<h3>Values</h3>
				<ul>
					<li>
						<h4>static</h4>
						<p>The element is positioned according to the normal flow of the document. The top, right, bottom, left, and z-index properties have no effect. This is the default value.</p>
					</li>
					<li>
						<h4>Relative</h4>
						<p>The element is positioned according to the normal flow of the document, and then offset relative to itself based on the values of top, right, bottom, and left. The offset does not affect the position of any other elements; thus, the space given for the element in the page layout is the same as if position were static.</p>
					</li>
					<li>
						<h4>absolute</h4>
						<p>The element is removed from the normal document flow, and no space is created for the element in the page layout. It is positioned relative to its closest positioned ancestor, if any; otherwise, it is placed relative to the initial containing block. Its final position is determined by the values of top, right, bottom, and left.</p>
					</li>
					<li>
						<h4>fixed</h4>
						<p>The element is removed from the normal document flow, and no space is created for the element in the page layout. It is positioned relative to the initial containing block established by the viewport, except when one of its ancestors has a transform, perspective, or filter property set to something other than none (see the CSS Transforms Spec), in which case that ancestor behaves as the containing block. (Note that there are browser inconsistencies with perspective and filter contributing to containing block formation.) Its final position is determined by the values of top, right, bottom, and left.</p>
					</li>
					<li>
						<h4>sticky</h4>
						<p>The element is positioned according to the normal flow of the document, and then offset relative to its nearest scrolling ancestor and containing block (nearest block-level ancestor), including table-related elements, based on the values of top, right, bottom, and left. The offset does not affect the position of any other elements.</p>
					</li>
				</ul>
			</section>
			<section class="main-section" id="@Keyframes">
				<header>
					<h1>@keyframes</h1>
				</header>
				<p>The @keyframes CSS at-rule controls the intermediate steps in a CSS animation sequence by defining styles for keyframes (or waypoints) along the animation sequence. This gives more control over the intermediate steps of the animation sequence than transitions.</p>
				<h3>Syntax</h3>
				<code>
					@keyframes slidein {<br>
  						from {
    							margin-left: 100%;
    							width: 300%;
  							}
							<br>
  						to {
    							margin-left: 0%;
    							width: 100%;
  							}
  							<br>
					}
				</code>
				<p>To use keyframes, create a @keyframes rule with a name that is then used by the animation-name property to match an animation to its keyframe declaration. Each @keyframes rule contains a style list of keyframe selectors, which specify percentages along the animation when the keyframe occurs, and a block containing the styles for that keyfram</p>
			</section>
			<section class="main-section" id="overflow">
				<header>
					<h1>Overflow</h1>
				</header>
				<p>The overflow shorthand CSS property sets what to do when an element's content is too big to fit in its block formatting context. It is a shorthand for overflow-x and overflow-y.</p>
				<h3>Syntax</h3>
				<code>
					.element {overflow: visible;} <br>
					.element {overflow: hidden;} <br>
					.element {overflow: clip;} <br>
					.element {overflow: scroll;} <br>
					.element {overflow: auto;} <br>
				</code>
				<h3>Values</h3>
				<ul>
					<li>
						<h4>Visible</h4>
						<p>Content is not clipped and may be rendered outside the padding bo</p>
					</li>
					<li>
						<h4>hidden</h4>
						<p>Content is clipped if necessary to fit the padding box. No scrollbars are provided, and no support for allowing the user to scroll (such as by dragging or using a scroll wheel) is allowed. The content can be scrolled programmatically (for example, by setting the value of a property such as offsetLeft), so the element is still a scroll container</p>
					</li>
					<li>
						<h4>clip</h4>
						<p>Like for hidden, the content is clipped to the element's padding box. The difference between clip and hidden is that the clip keyword also forbids all scrolling, including programmatic scrolling. The box is not a scroll container, and does not start a new formatting context. If you wish to start a new formatting context, you can use display: flow-root to do so.</p>
					</li>
					<li>
						<h4>scroll</h4>
						<p>Content is clipped if necessary to fit the padding box. Browsers always display scrollbars whether or not any content is actually clipped, preventing scrollbars from appearing or disappearing as content changes. Printers may still print overflowing content.</p>
					</li>
					<li>
						<h4>auto</h4>
						<p>Depends on the user agent. If content fits inside the padding box, it looks the same as visible, but still establishes a new block formatting context. Desktop browsers provide scrollbars if content overflows.</p>
					</li>
				</ul>
			</section>
			<section class="main-section" id="Text_Transform">
				<header>
					<h1>Text Transform</h1>
				</header>
				<p>The text-transform CSS property specifies how to capitalize an element's text. It can be used to make text appear in all-uppercase or all-lowercase, or with each word capitalized. It also can help improve legibility for ruby.</p>
				<p>The text-transform property takes into account language-specific case mapping rules such as the following:</p>
				<ul>
					<li>
						<p>In Turkic languages, like Turkish (tr), Azerbaijani (az), Crimean Tatar (crh), Volga Tatar (tt), and Bashkir (ba), there are two kinds of i, with and without the dot, and two case pairings: i/İ and ı/I.</p>
					</li>
					<li>
						<p>In German (de), the ß becomes SS in uppercase.</p>
					</li>
					<li>
						<p>In Dutch (nl), the ij digraph becomes IJ, even with text-transform: capitalize, which only puts the first letter of a word in uppercas</p>
					</li>
					<li>
						<p>In Greek (el), vowels lose their accent when the whole word is in uppercase (ά/Α), except for the disjunctive eta (ή/Ή). Also, diphthongs with an accent on the first vowel lose the accent and gain a diaeresis on the second vowel (άι/ΑΪ</p>
					</li>
					<li>
						<p>In Greek (el), the lowercase sigma character has two forms: σ and ς. ς is used only when sigma terminates a word. When applying text-transform: lowercase to an uppercase sigma (Σ), the browser needs to choose the right lowercase form based on context.</p>
					</li>
					<li>
						<p>in Irish (ga), certain prefixed letters remain in lowercase when the base initial is capitalized, so for example text-transform: uppercase will change ar aon tslí to AR AON tSLÍ and not, as one might expect, AR AON TSLÍ (Firefox only). In some cases, a hyphen is also removed upon uppercasing: an t-uisce transforms to AN tUISCE (and the hyphen is correctly reinserted by text-transform: lowercase).</p>
					</li>
				</ul>
				<h3>Syntax</h3>
				<code>
					/* Keyword values */
					.element {text-transform: none;} <br>
					.element {text-transform: capitalize;} <br>
					.element {text-transform: uppercase;} <br>
					.element {text-transform: lowercase;} <br>
				</code>
				<h3>Values</h3>
				<ul>
					<li>
						<h4>capitalize</h4>
						<p>Is a keyword that converts the first letter of each word to uppercase. Other characters remain unchanged (they retain their original case as written in the element's text</p>
					</li>
					<li>
						<h4>uppercase</h4>
						<p>Is a keyword that converts all characters to uppercase.</p>
					</li>
					<li>
						<h4>lowercase</h4>
						<p>Is a keyword that converts all characters to lowercase.</p>
					</li>
					<li>
						<h4>none</h4>
						<p>Is a keyword that prevents the case of all characters from being changed.</p>
					</li>
				</ul>
			</section>
			<section class="main-section" id="display">
				<header>
					<h1>Display</h1>
				</header>
				<p>The display CSS property sets whether an element is treated as a block or inline element and the layout used for its children, such as grid or flex.</p>
				<h3>Syntax</h3>
				<code>
					.element {display: block;} <br>
					.element {display: inline;} <br>
					.element {display: grid;} <br>
					.element {display: flex;} <br>
				</code>
			</section>
		</main>
	</div>
</body>
</html>